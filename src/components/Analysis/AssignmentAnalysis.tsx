import React, { useState, useEffect } from 'react';
import { AnalysisDashboard } from './AnalysisDashboard';
import { TeacherNotesPanel } from './TeacherNotesPanel';
import { StudentSimulationPanel } from './StudentSimulationPanel';
import { RubricBuilder } from './RubricBuilder';
import type {
  AssignmentAnalysis,
  AssignmentMetadataForAnalysis,
  TeacherNote,
  PeerReviewComment,
  StudentSimulation,
  GeneratedRubric,
  BloomLevel,
} from '../../agents/analysis/types';
import {
  extractTags,
  estimateTime,
  calculateClarityScore,
  calculateCompletenessScore,
  calculateAlignmentScore,
} from '../../agents/analysis/analyzeAssignment';
import { generatePeerReviewComments, generateSummaryComment } from '../../agents/analysis/generatePeerReview';
import { simulateStudentPerformance } from '../../agents/analysis/simulateStudents';
import { generateRubric } from '../../agents/analysis/generateRubric';

interface AssignmentAnalysisProps {
  assignmentMetadata: AssignmentMetadataForAnalysis;
  onAnalysisComplete?: (results: AnalysisResults) => void;
}

export interface AnalysisResults {
  analysis: AssignmentAnalysis;
  teacherNotes: TeacherNote[];
  studentSimulations: StudentSimulation[];
  rubric: GeneratedRubric;
  summaryComment: string;
}

export function AssignmentAnalysis({
  assignmentMetadata,
  onAnalysisComplete,
}: AssignmentAnalysisProps) {
  const [analysis, setAnalysis] = useState<AssignmentAnalysis | null>(null);
  const [teacherNotes, setTeacherNotes] = useState<TeacherNote[]>([]);
  const [studentSimulations, setStudentSimulations] = useState<StudentSimulation[]>([]);
  const [rubric, setRubric] = useState<GeneratedRubric | null>(null);
  const [summaryComment, setSummaryComment] = useState('');
  const [activeTab, setActiveTab] = useState<'dashboard' | 'notes' | 'students' | 'rubric'>('dashboard');
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    performAnalysis();
  }, [assignmentMetadata]);

  const performAnalysis = () => {
    setIsLoading(true);

    try {
      // Extract tags
      const tags = extractTags(
        assignmentMetadata.content,
        assignmentMetadata.learningObjectives,
        assignmentMetadata.extractedTags
      );

      // Create Bloom distribution
      let bloomDistribution: Record<BloomLevel, number> = {
        Remember: 0,
        Understand: 0,
        Apply: 0,
        Analyze: 0,
        Evaluate: 0,
        Create: 0,
      };

      if (assignmentMetadata.bloomLevels) {
        assignmentMetadata.bloomLevels.forEach(level => {
          bloomDistribution[level] = (bloomDistribution[level] || 0) + 1;
        });
      } else {
        // Default distribution if not provided: 50-60% lower, 30-40% mid, 10% higher
        bloomDistribution.Remember = 2;
        bloomDistribution.Understand = 2;
        bloomDistribution.Apply = 2;
        bloomDistribution.Analyze = 1;
        bloomDistribution.Create = 1;
      }

      // Estimate time
      const estimatedTime = estimateTime(
        assignmentMetadata.content,
        assignmentMetadata.learningObjectives,
        assignmentMetadata.estimatedTimeMinutes,
        bloomDistribution
      );

      // Calculate scores
      const clarityScore = calculateClarityScore(
        assignmentMetadata.content,
        bloomDistribution,
        !!assignmentMetadata.rubric
      );

      const completenessScore = calculateCompletenessScore(
        assignmentMetadata.learningObjectives.length > 0,
        !!assignmentMetadata.rubric,
        !!assignmentMetadata.estimatedTimeMinutes,
        assignmentMetadata.content.includes('Part') || assignmentMetadata.content.includes('Step'),
        assignmentMetadata.content.toLowerCase().includes('example')
      );

      const alignmentScore = calculateAlignmentScore(
        assignmentMetadata.learningObjectives,
        bloomDistribution,
        tags
      );

      const overallScore = Math.round((clarityScore + completenessScore + alignmentScore) / 3);

      // Generate peer review comments
      const peerReviewComments = generatePeerReviewComments(
        assignmentMetadata.content,
        assignmentMetadata.learningObjectives,
        tags,
        !!assignmentMetadata.rubric,
        bloomDistribution
      );

      // Create analysis object
      const analysisResult: AssignmentAnalysis = {
        estimatedTimeMinutes: estimatedTime,
        bloomDistribution,
        tagFrequency: tags,
        peerReviewComments,
        clarityScore,
        completenessScore,
        alignmentScore,
        overallScore,
      };

      // Generate rubric if needed
      const generatedRubric = assignmentMetadata.rubric
        ? {
            criteria: assignmentMetadata.rubric,
            totalPoints: 100,
            isAutoGenerated: false,
          }
        : generateRubric(
            assignmentMetadata.learningObjectives,
            bloomDistribution,
            100,
            assignmentMetadata.content.match(/Part \d+|Section \d+/g) || undefined
          );

      // Simulate students
      const simulations = simulateStudentPerformance(
        assignmentMetadata.content,
        estimatedTime,
        bloomDistribution,
        generatedRubric.criteria,
        assignmentMetadata.learningObjectives.length + 2
      );

      // Generate summary comment
      const summary = generateSummaryComment(clarityScore, completenessScore, alignmentScore);

      // Update state
      setAnalysis(analysisResult);
      setRubric(generatedRubric);
      setStudentSimulations(simulations);
      setSummaryComment(summary);

      // Call callback
      if (onAnalysisComplete) {
        onAnalysisComplete({
          analysis: analysisResult,
          teacherNotes,
          studentSimulations: simulations,
          rubric: generatedRubric,
          summaryComment: summary,
        });
      }
    } catch (err) {
      console.error('Analysis failed:', err);
      alert('Failed to analyze assignment. Please check the content and try again.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleNoteResolved = (note: TeacherNote) => {
    setTeacherNotes([...teacherNotes, note]);
  };

  const handleAIRewrite = async (comment: PeerReviewComment): Promise<string> => {
    // Simulate AI rewrite (in real implementation, call actual AI service)
    await new Promise(resolve => setTimeout(resolve, 1000));
    return `[AI-generated improvement for: "${comment.suggestion}"]`;
  };

  const handleRubricUpdate = (updatedRubric: GeneratedRubric) => {
    setRubric(updatedRubric);
  };

  const containerStyle: React.CSSProperties = {
    padding: '20px',
    backgroundColor: '#f5f5f5',
    minHeight: '100vh',
  };

  const tabsStyle: React.CSSProperties = {
    display: 'flex',
    gap: '0',
    marginBottom: '20px',
    backgroundColor: 'white',
    borderRadius: '8px 8px 0 0',
    borderBottom: '1px solid #ddd',
    overflow: 'hidden',
  };

  const tabStyle = (isActive: boolean): React.CSSProperties => ({
    flex: 1,
    padding: '12px 16px',
    textAlign: 'center',
    cursor: 'pointer',
    fontWeight: isActive ? '600' : '500',
    color: isActive ? '#2196f3' : '#666',
    backgroundColor: isActive ? 'white' : '#f5f5f5',
    borderBottom: isActive ? '3px solid #2196f3' : 'none',
    transition: 'all 0.3s ease',
  });

  const loadingStyle: React.CSSProperties = {
    textAlign: 'center',
    padding: '40px',
    backgroundColor: 'white',
    borderRadius: '8px',
    color: '#666',
  };

  return (
    <div style={containerStyle}>
      <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
        <h1 style={{ marginTop: 0, color: '#333' }}>üîç Assignment Analysis & Improvement</h1>

        {isLoading ? (
          <div style={loadingStyle}>
            <p style={{ fontSize: '16px', margin: 0 }}>‚è≥ Analyzing assignment...</p>
            <p style={{ fontSize: '13px', color: '#999', margin: '8px 0 0 0' }}>This may take a moment</p>
          </div>
        ) : analysis ? (
          <>
            {/* Summary Comment */}
            <div style={{
              backgroundColor: '#e3f2fd',
              border: '1px solid #2196f3',
              borderRadius: '8px',
              padding: '16px',
              marginBottom: '20px',
              color: '#1565c0',
              lineHeight: '1.6',
            }}>
              <strong>üìã Summary:</strong> {summaryComment}
            </div>

            {/* Tabs */}
            <div style={tabsStyle}>
              <div
                onClick={() => setActiveTab('dashboard')}
                style={tabStyle(activeTab === 'dashboard')}
              >
                üìä Dashboard
              </div>
              <div
                onClick={() => setActiveTab('notes')}
                style={tabStyle(activeTab === 'notes')}
              >
                üìù Notes ({analysis.peerReviewComments.length})
              </div>
              <div
                onClick={() => setActiveTab('students')}
                style={tabStyle(activeTab === 'students')}
              >
                üë• Simulations ({studentSimulations.length})
              </div>
              <div
                onClick={() => setActiveTab('rubric')}
                style={tabStyle(activeTab === 'rubric')}
              >
                ‚≠ê Rubric
              </div>
            </div>

            {/* Tab Content */}
            {activeTab === 'dashboard' && <AnalysisDashboard analysis={analysis} />}

            {activeTab === 'notes' && (
              <TeacherNotesPanel
                comments={analysis.peerReviewComments}
                onNoteResolved={handleNoteResolved}
                onAIRewrite={handleAIRewrite}
              />
            )}

            {activeTab === 'students' && (
              <StudentSimulationPanel simulations={studentSimulations} />
            )}

            {activeTab === 'rubric' && rubric && (
              <RubricBuilder
                rubric={rubric}
                bloomDistribution={analysis.bloomDistribution}
                onRubricUpdate={handleRubricUpdate}
              />
            )}
          </>
        ) : null}
      </div>
    </div>
  );
}

import { GeneratedRubric, RubricCriterion, BloomLevel } from './types';

/**
 * Generate a rubric based on learning objectives and Bloom distribution
 */
export function generateRubric(
  learningObjectives: string[],
  bloomDistribution: Record<BloomLevel, number>,
  totalPoints: number = 100,
  assignmentParts?: string[]
): GeneratedRubric {
  const criteria: RubricCriterion[] = [];
  let pointsAllocated = 0;
  let id = 1;

  // Create criteria for each learning objective
  learningObjectives.forEach((objective, idx) => {
    const points = Math.ceil(totalPoints / learningObjectives.length);
    const bloomLevel = getObjectiveBloomLevel(objective, bloomDistribution);
    
    criteria.push({
      id: `criterion-${id++}`,
      name: `${bloomLevel} - ${objective}`,
      description: generateCriterionDescription(objective, bloomLevel),
      maxPoints: points,
      bloomLevels: [bloomLevel],
    });
    
    pointsAllocated += points;
  });

  // Add assignment part criteria if provided
  if (assignmentParts && assignmentParts.length > 0) {
    const remainingPoints = totalPoints - pointsAllocated;
    const pointsPerPart = Math.floor(remainingPoints / assignmentParts.length);
    
    assignmentParts.slice(0, 3).forEach((part, idx) => {
      criteria.push({
        id: `criterion-${id++}`,
        name: `Completion and Accuracy - ${part}`,
        description: `Accurately completes ${part} with no significant errors or omissions.`,
        maxPoints: pointsPerPart,
        bloomLevels: ['Apply'],
      });
      pointsAllocated += pointsPerPart;
    });
  }

  // Add holistic criteria
  const holisticPoints = totalPoints - pointsAllocated;
  if (holisticPoints > 0) {
    criteria.push({
      id: `criterion-${id++}`,
      name: 'Organization and Communication',
      description: 'Work is well-organized, clearly written, and easy to follow. Demonstrates effective communication of ideas.',
      maxPoints: holisticPoints,
      bloomLevels: ['Understand'],
    });
  }

  return {
    criteria,
    totalPoints,
    isAutoGenerated: true,
  };
}

/**
 * Determine the primary Bloom level for an objective
 */
function getObjectiveBloomLevel(objective: string, bloomDistribution: Record<BloomLevel, number>): BloomLevel {
  const lower = objective.toLowerCase();

  // Check against Bloom keywords
  const bloomLevels: BloomLevel[] = ['Create', 'Evaluate', 'Analyze', 'Apply', 'Understand', 'Remember'];

  for (const level of bloomLevels) {
    const keywords = getBloomKeywords(level);
    if (keywords.some(kw => lower.includes(kw))) {
      return level;
    }
  }

  // Default to most prevalent Bloom level in distribution
  let maxLevel: BloomLevel = 'Remember';
  let maxCount = 0;
  Object.entries(bloomDistribution).forEach(([level, count]) => {
    if (count > maxCount) {
      maxCount = count;
      maxLevel = level as BloomLevel;
    }
  });

  return maxLevel;
}

/**
 * Get keywords for each Bloom level
 */
function getBloomKeywords(level: BloomLevel): string[] {
  const keywords: Record<BloomLevel, string[]> = {
    Remember: ['define', 'list', 'recall', 'identify', 'name', 'state', 'label', 'match', 'recognize'],
    Understand: ['explain', 'describe', 'summarize', 'paraphrase', 'interpret', 'discuss', 'classify', 'distinguish'],
    Apply: ['calculate', 'apply', 'use', 'demonstrate', 'solve', 'illustrate', 'complete', 'practice', 'construct'],
    Analyze: ['compare', 'analyze', 'distinguish', 'examine', 'categorize', 'organize', 'differentiate', 'break down'],
    Evaluate: ['evaluate', 'justify', 'assess', 'critique', 'judge', 'defend', 'argue', 'debate', 'appraise'],
    Create: ['design', 'create', 'develop', 'propose', 'construct', 'generate', 'plan', 'synthesize', 'invent'],
  };

  return keywords[level] || [];
}

/**
 * Generate a detailed description for a rubric criterion
 */
function generateCriterionDescription(objective: string, bloomLevel: BloomLevel): string {
  const descriptions: Record<BloomLevel, (obj: string) => string> = {
    Remember: (obj: string) => `Student accurately recalls and identifies key facts and concepts related to ${obj}.`,
    Understand: (obj: string) => `Student demonstrates clear understanding of ${obj} and can explain the concepts in their own words.`,
    Apply: (obj: string) => `Student correctly applies ${obj} to solve problems or complete tasks with minimal errors.`,
    Analyze: (obj: string) => `Student breaks down ${obj}, identifies patterns and relationships, and explains how components work together.`,
    Evaluate: (obj: string) => `Student makes informed judgments about ${obj}, supporting claims with evidence and reasoning.`,
    Create: (obj: string) => `Student generates original work demonstrating ${obj}, combining ideas in novel ways and showing creative thinking.`,
  };

  return descriptions[bloomLevel](objective);
}

/**
 * Convert numeric rubric to point distribution
 */
export function distributeRubricPoints(criteria: RubricCriterion[], totalPoints: number): RubricCriterion[] {
  if (criteria.length === 0) return criteria;

  const currentTotal = criteria.reduce((sum, c) => sum + c.maxPoints, 0);
  const scaleFactor = totalPoints / (currentTotal || 1);

  return criteria.map(c => ({
    ...c,
    maxPoints: Math.round(c.maxPoints * scaleFactor),
  }));
}

/**
 * Suggest rubric improvements based on assignment
 */
export function suggestRubricImprovements(
  rubric: RubricCriterion[],
  bloomDistribution: Record<BloomLevel, number>
): string[] {
  const suggestions: string[] = [];

  // Check if rubric covers higher-order thinking
  const rubricHasHigherOrder = rubric.some(c => 
    c.bloomLevels.includes('Analyze') || 
    c.bloomLevels.includes('Evaluate') || 
    c.bloomLevels.includes('Create')
  );
  const assignmentHasHigherOrder = bloomDistribution.Analyze || bloomDistribution.Evaluate || bloomDistribution.Create;

  if (assignmentHasHigherOrder && !rubricHasHigherOrder) {
    suggestions.push('The rubric should include criteria for higher-order thinking (Analyze, Evaluate, Create) to match the assignment complexity.');
  }

  // Check balance
  const avgPointValue = rubric.reduce((sum, c) => sum + c.maxPoints, 0) / rubric.length;
  if (avgPointValue < 5) {
    suggestions.push('Consider increasing point values per criterion to better differentiate performance levels.');
  }

  // Check criteria count
  if (rubric.length > 10) {
    suggestions.push('The rubric has many criteria. Consider consolidating related criteria to simplify grading.');
  }

  if (rubric.length < 3) {
    suggestions.push('Add more specific criteria to provide clearer expectations for students.');
  }

  // Check for descriptors
  const hasWeakDescriptors = rubric.some(c => c.description.length < 20);
  if (hasWeakDescriptors) {
    suggestions.push('Some criteria lack detailed descriptions. Add more specific guidance for what constitutes quality work.');
  }

  return suggestions;
}
